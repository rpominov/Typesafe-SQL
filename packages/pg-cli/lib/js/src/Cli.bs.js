// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Float = require("rescript/lib/js/belt_Float.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var PathRebuild = require("rescript-path-rebuild/lib/js/PathRebuild.bs.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");
var TTY$TypesafeSqlPgCli = require("./TTY.bs.js");
var Native$TypesafeSqlErrors = require("@typesafe-sql/rescript-errors/lib/js/src/Native.bs.js");
var Process$TypesafeSqlPgCli = require("./Process.bs.js");
var Require$TypesafeSqlPgCli = require("./Require.bs.js");
var Commands$TypesafeSqlPgCli = require("./Commands.bs.js");
var Minimist$TypesafeSqlPgCli = require("./Minimist.bs.js");
var Loggable$TypesafeSqlErrors = require("@typesafe-sql/rescript-errors/lib/js/src/Loggable.bs.js");

var version = "0.1.0";

var header = "Typesafe SQL CLI for PostgreSQL [ver. " + version + "]\n\nThis is a tool for generating typings for PostgreSQL queries.";

var usage = "Usage: typesafe-pg [--version | -v] <command> \n       [--input | -i <glob>] [--output | -o <pattern>] [--generator | -g <generator>]\n       [--config | -c <path>] [--host | -h <db-host>] [--port | -p <db-port>]\n       [--username | -U <db-user>] [--password | -W <db-password>]\n       [--dbname | -d <db-database-name>] [--connection | -C <db-connection-string>]\n       [--debug | -D] [--quiet | -q] [--color | --no-color]\n\ntypesafe-pg build - Generate typings\ntypesafe-pg watch - Generate, and continue updating as the input files change\ntypesafe-pg pipe  - Generate using stdin as the input and output to stdout \n\nExample:\n\n  $ typesafe-pg build \\\n    --connection \"postgres://user:password@host:5432/database\" \\\n    --input \"queries/*.sql\" \\\n    --output \"{dir}/{name}.res\" \\\n    --generator rescript\n       \nFull documentation is available at \nhttps://github.com/rpominov/typesafe-sql/tree/master/packages/pg-cli\n";

var quiet = {
  contents: false
};

function exitWithError(err) {
  return Process$TypesafeSqlPgCli.exitWithError(Caml_option.some(quiet.contents ? undefined : usage), err);
}

function exitWithLoggableError(err) {
  return Process$TypesafeSqlPgCli.exitWithLoggableError(Caml_option.some(quiet.contents ? undefined : usage), err);
}

var x = Belt_Array.get(Process$TypesafeSqlPgCli.argv, 2);

var match = x !== undefined ? (
    x.startsWith("-") ? [
        undefined,
        Process$TypesafeSqlPgCli.argv.slice(2)
      ] : [
        x,
        Process$TypesafeSqlPgCli.argv.slice(3)
      ]
  ) : [
    undefined,
    []
  ];

var unparsedArgv = match[1];

var command = match[0];

var command$1;

if (command !== undefined) {
  switch (command) {
    case "build" :
        command$1 = "build";
        break;
    case "pipe" :
        command$1 = "pipe";
        break;
    case "watch" :
        command$1 = "watch";
        break;
    default:
      command$1 = exitWithError("Unknown command: " + command);
  }
} else {
  command$1 = "help";
}

function outputValidator(name) {
  return Require$TypesafeSqlPgCli.Validators.either(Require$TypesafeSqlPgCli.Validators.string, (function (str) {
                if (str === "") {
                  return {
                          TAG: /* Error */1,
                          _0: Loggable$TypesafeSqlErrors.fromText("Invalid \"" + name + "\" value. It cannot be an empty string.")
                        };
                }
                var fn = PathRebuild.make(str);
                if (fn.TAG === /* Ok */0) {
                  return {
                          TAG: /* Ok */0,
                          _0: fn._0
                        };
                } else {
                  return {
                          TAG: /* Error */1,
                          _0: Loggable$TypesafeSqlErrors.fromText("Invalid \"" + name + "\" value. " + fn._0)
                        };
                }
              }), Require$TypesafeSqlPgCli.Validators.$$function, (function (fn) {
                return {
                        TAG: /* Ok */0,
                        _0: (function (str) {
                            return fn(str);
                          })
                      };
              }));
}

function resolveGenerator(moduleId) {
  var err = Require$TypesafeSqlPgCli.$$require(moduleId);
  var ok;
  if (err.TAG === /* Ok */0) {
    var obj = err._0;
    if (obj !== undefined) {
      var obj$1 = Caml_option.valFromOption(obj);
      ok = Require$TypesafeSqlPgCli.validate(function (param) {
            var obj$2 = Require$TypesafeSqlPgCli.Validators.cast(obj$1, Require$TypesafeSqlPgCli.Validators.object, "The export");
            return {
                    name: moduleId,
                    defaultOutputPath: Require$TypesafeSqlPgCli.Validators.property(obj$2, "defaultOutputPath", outputValidator("defaultOutputPath")),
                    generate: Require$TypesafeSqlPgCli.Validators.property(obj$2, "generate", Require$TypesafeSqlPgCli.Validators.$$function)
                  };
          });
    } else {
      ok = {
        TAG: /* Error */1,
        _0: Loggable$TypesafeSqlErrors.fromText("Not found")
      };
    }
  } else {
    ok = err;
  }
  if (ok.TAG === /* Ok */0) {
    return ok;
  } else {
    return {
            TAG: /* Error */1,
            _0: Loggable$TypesafeSqlErrors.prepend(ok._0, "Failed to load generator from \"" + moduleId + "\". Reason:\n")
          };
  }
}

var ArgsParseError = /* @__PURE__ */Caml_exceptions.create("Cli-TypesafeSqlPgCli.ArgsParseError");

var argv;

try {
  var result = Minimist$TypesafeSqlPgCli.parse([
        "generator",
        "output",
        "input",
        "config",
        "host",
        "port",
        "username",
        "password",
        "dbname",
        "connection"
      ], [
        "version",
        "debug",
        "quiet",
        "color"
      ], {
        version: "v",
        generator: "g",
        debug: "D",
        input: "i",
        output: "o",
        quiet: "q",
        config: "c",
        host: "h",
        port: "p",
        username: "U",
        password: "W",
        dbname: "d",
        connection: "C"
      }, undefined, true, (function (s) {
          throw {
                RE_EXN_ID: ArgsParseError,
                _1: {
                  TAG: /* UnknownParameter */1,
                  _0: s
                },
                Error: new Error()
              };
        }), unparsedArgv);
  var getFlagExn = function (name) {
    var v = Minimist$TypesafeSqlPgCli.get(result, name);
    if (typeof v === "number") {
      throw {
            RE_EXN_ID: ArgsParseError,
            _1: {
              TAG: /* InvalidFlag */0,
              _0: name,
              _1: v
            },
            Error: new Error()
          };
    }
    switch (v.TAG | 0) {
      case /* Bool */0 :
          return v._0;
      case /* String */1 :
          switch (v._0) {
            case "false" :
                return false;
            case "true" :
                return true;
            default:
              throw {
                    RE_EXN_ID: ArgsParseError,
                    _1: {
                      TAG: /* InvalidFlag */0,
                      _0: name,
                      _1: v
                    },
                    Error: new Error()
                  };
          }
      case /* Float */2 :
          throw {
                RE_EXN_ID: ArgsParseError,
                _1: {
                  TAG: /* InvalidFlag */0,
                  _0: name,
                  _1: v
                },
                Error: new Error()
              };
      
    }
  };
  var getParam = function (name) {
    var val = Minimist$TypesafeSqlPgCli.get(result, name);
    if (typeof val === "number" || val.TAG !== /* String */1) {
      return ;
    } else {
      return val._0;
    }
  };
  quiet.contents = getFlagExn("quiet");
  if (unparsedArgv.includes("--")) {
    throw {
          RE_EXN_ID: ArgsParseError,
          _1: {
            TAG: /* UnknownParameter */1,
            _0: "--"
          },
          Error: new Error()
        };
  }
  var arr = result._;
  if (arr.length !== 0) {
    throw {
          RE_EXN_ID: ArgsParseError,
          _1: {
            TAG: /* UnknownParameter */1,
            _0: arr[0]
          },
          Error: new Error()
        };
  }
  var name = getParam("generator");
  var generator;
  if (name !== undefined) {
    var generator$1 = resolveGenerator(name);
    if (generator$1.TAG === /* Ok */0) {
      generator = generator$1._0;
    } else {
      throw {
            RE_EXN_ID: ArgsParseError,
            _1: {
              TAG: /* ParameterLoggableError */3,
              _0: "generator",
              _1: generator$1._0
            },
            Error: new Error()
          };
    }
  } else {
    generator = undefined;
  }
  var str = getParam("output");
  var tmp;
  if (str !== undefined) {
    if (str === "") {
      throw {
            RE_EXN_ID: ArgsParseError,
            _1: {
              TAG: /* ParameterError */2,
              _0: "output",
              _1: "It cannot be an empty string."
            },
            Error: new Error()
          };
    }
    var fn = PathRebuild.make(str);
    if (fn.TAG === /* Ok */0) {
      tmp = fn._0;
    } else {
      throw {
            RE_EXN_ID: ArgsParseError,
            _1: {
              TAG: /* ParameterError */2,
              _0: "output",
              _1: fn._0
            },
            Error: new Error()
          };
    }
  } else {
    tmp = undefined;
  }
  var str$1 = getParam("port");
  var tmp$1;
  if (str$1 !== undefined) {
    var $$float = Belt_Float.fromString(str$1);
    if ($$float !== undefined) {
      if (($$float | 0) === $$float) {
        tmp$1 = $$float | 0;
      } else {
        throw {
              RE_EXN_ID: ArgsParseError,
              _1: {
                TAG: /* ParameterError */2,
                _0: "port",
                _1: "Not an integer: " + str$1
              },
              Error: new Error()
            };
      }
    } else {
      throw {
            RE_EXN_ID: ArgsParseError,
            _1: {
              TAG: /* ParameterError */2,
              _0: "port",
              _1: "Not an integer: " + str$1
            },
            Error: new Error()
          };
    }
  } else {
    tmp$1 = undefined;
  }
  argv = {
    version: getFlagExn("version"),
    debug: getFlagExn("debug"),
    quiet: getFlagExn("quiet"),
    generator: generator,
    input: getParam("input"),
    output: tmp,
    config: getParam("config"),
    host: getParam("host"),
    port: tmp$1,
    username: getParam("username"),
    password: getParam("password"),
    dbname: getParam("dbname"),
    connection: getParam("connection")
  };
}
catch (raw_error){
  var error = Caml_js_exceptions.internalToOCamlException(raw_error);
  if (error.RE_EXN_ID === ArgsParseError) {
    var error$1 = error._1;
    switch (error$1.TAG | 0) {
      case /* InvalidFlag */0 :
          var str$2 = error$1._1;
          var name$1 = error$1._0;
          if (typeof str$2 === "number") {
            argv = exitWithError("Invalid --" + name$1 + " value. A boolen flag can have values true/false or no value.");
          } else {
            switch (str$2.TAG | 0) {
              case /* Bool */0 :
                  argv = exitWithError("Invalid --" + name$1 + " value. A boolen flag can have values true/false or no value.");
                  break;
              case /* String */1 :
                  argv = exitWithError("Invalid --" + name$1 + " value. A boolen flag can have values true/false or no value, got: " + str$2._0);
                  break;
              case /* Float */2 :
                  argv = exitWithError("Invalid --" + name$1 + " value. A boolen flag can have values true/false or no value, got: " + str$2._0.toString());
                  break;
              
            }
          }
          break;
      case /* UnknownParameter */1 :
          argv = exitWithError("Unknown argument: " + error$1._0);
          break;
      case /* ParameterError */2 :
          argv = exitWithError("Invalid --" + error$1._0 + " value. " + error$1._1);
          break;
      case /* ParameterLoggableError */3 :
          argv = exitWithLoggableError(Loggable$TypesafeSqlErrors.prepend(error$1._1, "Invalid --" + error$1._0 + " value."));
          break;
      
    }
  } else {
    argv = Native$TypesafeSqlErrors.rethrowAsNative(error);
  }
}

if (argv.version) {
  console.log(version);
} else {
  var path = argv.config;
  var res;
  if (path !== undefined) {
    var result$1 = Require$TypesafeSqlPgCli.$$require(path);
    res = result$1.TAG === /* Ok */0 && result$1._0 === undefined ? [
        path,
        {
          TAG: /* Error */1,
          _0: Loggable$TypesafeSqlErrors.fromText("File doesn't exist")
        }
      ] : [
        path,
        result$1
      ];
  } else {
    var res$1 = Require$TypesafeSqlPgCli.$$require("./typesafe-pg.config.json");
    if (res$1.TAG === /* Ok */0 && res$1._0 === undefined) {
      var res$2 = Require$TypesafeSqlPgCli.$$require("./typesafe-pg.config.js");
      if (res$2.TAG === /* Ok */0 && res$2._0 === undefined) {
        var res$3 = Require$TypesafeSqlPgCli.$$require("./package.json");
        if (res$3.TAG === /* Ok */0) {
          var obj = res$3._0;
          if (obj !== undefined) {
            var obj$1 = Caml_option.valFromOption(obj);
            res = [
              "./package.json",
              Require$TypesafeSqlPgCli.validate(function (param) {
                    return Require$TypesafeSqlPgCli.Validators.property(Require$TypesafeSqlPgCli.Validators.cast(obj$1, Require$TypesafeSqlPgCli.Validators.object, "This"), "typesafe-pg", Require$TypesafeSqlPgCli.Validators.nullable(Require$TypesafeSqlPgCli.Validators.unknown));
                  })
            ];
          } else {
            res = [
              "./package.json",
              res$3
            ];
          }
        } else {
          res = [
            "./package.json",
            res$3
          ];
        }
      } else {
        res = [
          "./typesafe-pg.config.js",
          res$2
        ];
      }
    } else {
      res = [
        "./typesafe-pg.config.json",
        res$1
      ];
    }
  }
  var match$1 = res[1];
  var match$2;
  if (match$1.TAG === /* Ok */0) {
    var obj$2 = match$1._0;
    if (obj$2 !== undefined) {
      var obj$3 = Caml_option.valFromOption(obj$2);
      match$2 = [
        res[0],
        Require$TypesafeSqlPgCli.validate(function (param) {
              var obj$4 = Require$TypesafeSqlPgCli.Validators.cast(obj$3, Require$TypesafeSqlPgCli.Validators.object, "This");
              var name = Require$TypesafeSqlPgCli.Validators.property(obj$4, "generator", Require$TypesafeSqlPgCli.Validators.nullable(Require$TypesafeSqlPgCli.Validators.string));
              var generator;
              if (name !== undefined) {
                var error = resolveGenerator(name);
                generator = error.TAG === /* Ok */0 ? error._0 : Require$TypesafeSqlPgCli.Validators.failed(error._0);
              } else {
                generator = undefined;
              }
              var some = Require$TypesafeSqlPgCli.Validators.property(obj$4, "sources", Require$TypesafeSqlPgCli.Validators.nullable(Require$TypesafeSqlPgCli.Validators.arrayOf(Require$TypesafeSqlPgCli.Validators.objectOf2("input", Require$TypesafeSqlPgCli.Validators.either(Require$TypesafeSqlPgCli.Validators.string, (function (x) {
                                      return {
                                              TAG: /* Ok */0,
                                              _0: [x]
                                            };
                                    }), Require$TypesafeSqlPgCli.Validators.arrayOf(Require$TypesafeSqlPgCli.Validators.string), (function (xs) {
                                      return {
                                              TAG: /* Ok */0,
                                              _0: xs
                                            };
                                    })), "output", Require$TypesafeSqlPgCli.Validators.nullable(outputValidator("output")), (function (i, o) {
                                  return {
                                          input: i,
                                          output: o
                                        };
                                })))));
              return {
                      debug: Require$TypesafeSqlPgCli.Validators.property(obj$4, "debug", Require$TypesafeSqlPgCli.Validators.nullable(Require$TypesafeSqlPgCli.Validators.bool)),
                      quiet: Require$TypesafeSqlPgCli.Validators.property(obj$4, "quiet", Require$TypesafeSqlPgCli.Validators.nullable(Require$TypesafeSqlPgCli.Validators.bool)),
                      generator: generator,
                      host: Require$TypesafeSqlPgCli.Validators.property(obj$4, "host", Require$TypesafeSqlPgCli.Validators.nullable(Require$TypesafeSqlPgCli.Validators.string)),
                      port: Require$TypesafeSqlPgCli.Validators.property(obj$4, "port", Require$TypesafeSqlPgCli.Validators.nullable(Require$TypesafeSqlPgCli.Validators.$$int)),
                      username: Require$TypesafeSqlPgCli.Validators.property(obj$4, "username", Require$TypesafeSqlPgCli.Validators.nullable(Require$TypesafeSqlPgCli.Validators.string)),
                      password: Require$TypesafeSqlPgCli.Validators.property(obj$4, "password", Require$TypesafeSqlPgCli.Validators.nullable(Require$TypesafeSqlPgCli.Validators.string)),
                      dbname: Require$TypesafeSqlPgCli.Validators.property(obj$4, "dbname", Require$TypesafeSqlPgCli.Validators.nullable(Require$TypesafeSqlPgCli.Validators.string)),
                      connection: Require$TypesafeSqlPgCli.Validators.property(obj$4, "connection", Require$TypesafeSqlPgCli.Validators.nullable(Require$TypesafeSqlPgCli.Validators.string)),
                      sources: some !== undefined && some.length !== 0 ? some : undefined
                    };
            })
      ];
    } else {
      match$2 = [
        "%fallback",
        {
          TAG: /* Ok */0,
          _0: {
            debug: undefined,
            quiet: undefined,
            generator: undefined,
            host: undefined,
            port: undefined,
            username: undefined,
            password: undefined,
            dbname: undefined,
            connection: undefined,
            sources: undefined
          }
        }
      ];
    }
  } else {
    match$2 = res;
  }
  var data = match$2[1];
  var path$1 = match$2[0];
  var config;
  if (data.TAG === /* Ok */0) {
    if (!quiet.contents && command$1 !== "help") {
      console.error(TTY$TypesafeSqlPgCli.Chalk.dim("Using config from:"), TTY$TypesafeSqlPgCli.Chalk.dim(path$1));
    }
    config = data._0;
  } else {
    config = exitWithLoggableError(Loggable$TypesafeSqlErrors.prepend(data._0, "Failed to load config file \"" + path$1 + "\"! Reason:\n\n"));
  }
  var ctx = {
    config: config,
    argv: argv
  };
  if (command$1 === "watch") {
    Commands$TypesafeSqlPgCli.watch(ctx);
  } else if (command$1 === "pipe") {
    Commands$TypesafeSqlPgCli.pipe(ctx);
  } else if (command$1 === "build") {
    Commands$TypesafeSqlPgCli.build(ctx);
  } else {
    TTY$TypesafeSqlPgCli.info(ctx, header);
    TTY$TypesafeSqlPgCli.infoNl(ctx);
    TTY$TypesafeSqlPgCli.info(ctx, usage);
  }
}

var Loggable;

var NativeError;

exports.Loggable = Loggable;
exports.NativeError = NativeError;
exports.version = version;
exports.header = header;
exports.usage = usage;
exports.quiet = quiet;
exports.exitWithError = exitWithError;
exports.exitWithLoggableError = exitWithLoggableError;
exports.unparsedArgv = unparsedArgv;
exports.command = command$1;
exports.outputValidator = outputValidator;
exports.resolveGenerator = resolveGenerator;
exports.ArgsParseError = ArgsParseError;
exports.argv = argv;
/* x Not a pure module */
