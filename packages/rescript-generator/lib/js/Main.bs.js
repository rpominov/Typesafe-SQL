// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var PgTypes = require("@typesafe-sql/rescript-common/lib/js/src/PgTypes.bs.js");

function pgToReasonType(datatype) {
  if (datatype.namespace.nspname === "pg_catalog" && PgTypes.isDefiend(datatype.typname)) {
    return "PgTypes." + PgTypes.fixName(datatype.typname);
  } else {
    return "PgTypes.unknown";
  }
}

function indent(str) {
  return "  " + str.split("\n").join("\n  ");
}

function tupleOf(items) {
  return "(" + items.join(", ") + ")";
}

function recordOf(items) {
  if (items.length === 0) {
    return "()";
  } else {
    return [
              "{",
              indent(items.map(function (param) {
                          return param[0] + ": " + param[1];
                        }).join(",\n")),
              "}"
            ].join("\n");
  }
}

function codeComment(str) {
  return "// " + str.split("\n").join("\n// ");
}

function moduleDefinition(name, body) {
  return [
            "module " + name.charAt(0).toUpperCase() + name.slice(1) + " = {",
            indent(body),
            "}"
          ].join("\n");
}

function stringVar(name, content) {
  return "let " + name + " = " + JSON.stringify(content);
}

function typeDefinition(name, value) {
  return "type " + name + " = " + value;
}

function uniqueBy(arr, fn) {
  return Js_dict.values(Js_dict.fromArray(arr.map(function (x) {
                      return [
                              Curry._1(fn, x),
                              x
                            ];
                    })));
}

function generateItem(data) {
  var arr = data.columns;
  var match = data.columns;
  return moduleDefinition(data.name, [
                codeComment(data.originalStatement),
                stringVar("statement", data.processedStatement),
                typeDefinition("parameters", tupleOf(data.parameters.map(function (p) {
                              return pgToReasonType(p.datatype);
                            }))),
                typeDefinition("parametersRecord", recordOf(uniqueBy(data.parameters, (function (p) {
                                  return p.name;
                                })).map(function (p) {
                              return [
                                      p.name,
                                      pgToReasonType(p.datatype)
                                    ];
                            }))),
                "let convertParameters = (rec: parametersRecord): parameters => (" + data.parameters.map(function (p) {
                        return "rec." + p.name;
                      }).join(", ") + ")",
                typeDefinition("column", arr !== undefined ? tupleOf(arr.map(function (p) {
                                return pgToReasonType(p.type);
                              })) : "unit"),
                typeDefinition("columns", match !== undefined ? "array<column>" : "unit")
              ].join("\n"));
}

function generator(data) {
  return Promise.resolve(data.map(generateItem).join("\n\n"));
}

var S;

var A;

exports.S = S;
exports.A = A;
exports.pgToReasonType = pgToReasonType;
exports.indent = indent;
exports.tupleOf = tupleOf;
exports.recordOf = recordOf;
exports.codeComment = codeComment;
exports.moduleDefinition = moduleDefinition;
exports.stringVar = stringVar;
exports.typeDefinition = typeDefinition;
exports.uniqueBy = uniqueBy;
exports.generateItem = generateItem;
exports.generator = generator;
/* No side effect */
