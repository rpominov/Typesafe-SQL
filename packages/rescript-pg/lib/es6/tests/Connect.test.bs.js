// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Pg from "../Pg.bs.js";
import * as Pg$1 from "pg";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Process from "process";
import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function $$then(promise, fn) {
  return promise.then(Curry.__1(fn));
}

test("No config", (function () {
        var client = Pg.Client.make(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
        var promise = client.connect();
        return promise.then(function (param) {
                    return client.end();
                  });
      }));

function getExn(opt, loc) {
  if (opt !== undefined) {
    return Caml_option.valFromOption(opt);
  } else {
    return Js_exn.raiseError("Unexpected None at: " + loc);
  }
}

var env = Process.env;

var pgUser = getExn(Js_dict.get(env, "PGUSER"), "File \"Connect.test.res\", line 17, characters 48-55");

var pgPassword = getExn(Js_dict.get(env, "PGPASSWORD"), "File \"Connect.test.res\", line 18, characters 56-63");

var pgDatabase = getExn(Js_dict.get(env, "PGDATABASE"), "File \"Connect.test.res\", line 19, characters 56-63");

var pgHost = getExn(Js_dict.get(env, "PGHOST"), "File \"Connect.test.res\", line 20, characters 48-55");

var pgPort = getExn(Belt_Int.fromString(getExn(Js_dict.get(env, "PGPORT"), "File \"Connect.test.res\", line 21, characters 48-55")), "File \"Connect.test.res\", line 21, characters 86-93");

test("With config", (function () {
        var client = Pg.Client.make(pgUser, Caml_option.some(pgPassword), pgHost, pgDatabase, pgPort, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
        var promise = client.connect();
        return promise.then(function (param) {
                    return client.end();
                  });
      }));

test("Extra options", (function () {
        var client = Pg.Client.make(pgUser, Caml_option.some(pgPassword), pgHost, pgDatabase, pgPort, undefined, 1000, 1000, "Test", 1000, 1000, undefined, undefined, undefined);
        var promise = client.connect();
        return promise.then(function (param) {
                    return client.end();
                  });
      }));

test("Async password", (function () {
        var makePass1 = function (pass, param) {
          return Promise.resolve(pass);
        };
        var makePass2 = function (pass, param) {
          return Promise.resolve(pass);
        };
        var makePass = Math.random() > 0.5 ? makePass1 : makePass2;
        var client = Pg.Client.make(pgUser, Caml_option.some(Curry._1(makePass, pgPassword)), pgHost, pgDatabase, pgPort, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
        var promise = client.connect();
        return promise.then(function (param) {
                    return client.end();
                  });
      }));

test("Callbacks", (function (done) {
        expect.assertions(2);
        var client = Pg.Client.make(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
        return Pg.Client.connectCb(client, (function (res1) {
                      return Pg.Client.endCb(client, (function (res2) {
                                    expect(res1).toEqual({
                                          TAG: /* Ok */0,
                                          _0: undefined
                                        });
                                    expect(res2).toEqual({
                                          TAG: /* Ok */0,
                                          _0: undefined
                                        });
                                    return done();
                                  }));
                    }));
      }));

test("Custom type parser", (function () {
        expect.assertions(1);
        var typesParser = Pg.TypesParser.make(Caml_option.some(Pg$1.types), undefined);
        typesParser.setTypeParser(23, (function (str) {
                return "Custom: " + str;
              }));
        var client = Pg.Client.make(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, Caml_option.some(typesParser), undefined);
        var promise = client.connect();
        var promise$1 = promise.then(function (param) {
              return Pg.query(client, undefined, "SELECT 42 num, TRUE bool");
            });
        return promise$1.then(function (result) {
                    var promise = client.end();
                    return promise.then(function (param) {
                                expect(result.rows).toEqual([{
                                        num: "Custom: 42",
                                        bool: true
                                      }]);
                                return Promise.resolve(undefined);
                              });
                  });
      }));

export {
  $$then ,
  getExn ,
  env ,
  pgUser ,
  pgPassword ,
  pgDatabase ,
  pgHost ,
  pgPort ,
  
}
/*  Not a pure module */
