// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Js_exn = require("rescript/lib/js/js_exn.js");

function end(state) {
  return state.pos > state.maxPos;
}

function at(state, pos) {
  if (pos <= state.maxPos && pos >= state.minPos) {
    return state.symbols[pos];
  } else {
    return "";
  }
}

function back(state, offset) {
  state.pos = state.pos - offset | 0;
  var minPos = state.minPos;
  var pos = state.pos;
  if (state.pos < minPos) {
    return Js_exn.raiseError("The position can't be less than " + minPos + " got: " + pos + ". This indicates a bug in the parser!");
  }
  
}

function skip(state, offset) {
  state.pos = state.pos + offset | 0;
  var pos = state.pos;
  var maxPos = state.maxPos + 1 | 0;
  if (state.pos > maxPos) {
    return Js_exn.raiseError("The position can't be more than " + maxPos + " got: " + pos + ". This indicates a bug in the parser!");
  }
  
}

function current2(state) {
  return [
          at(state, state.pos),
          at(state, state.pos + 1 | 0)
        ];
}

function skipUntil(state, predicate) {
  while(state.pos <= state.maxPos && !predicate(state.symbols[state.pos])) {
    state.pos = state.pos + 1 | 0;
  };
  
}

function cutStr(state, start, end) {
  return state.symbols.slice(start, end + 1 | 0).join("");
}

function parseInlineComment(state) {
  skip(state, 2);
  var start = state.pos;
  skipUntil(state, (function (x) {
          return x === "\n";
        }));
  back(state, 1);
  return {
          TAG: /* Ok */0,
          _0: {
            NAME: "InlineComment",
            VAL: cutStr(state, start, state.pos)
          }
        };
}

function parseBlockComment(state) {
  skip(state, 2);
  var loop = function (_acc) {
    while(true) {
      var acc = _acc;
      if (end(state)) {
        return {
                TAG: /* Error */1,
                _0: {
                  TAG: /* AutoLocationStart */2,
                  _0: "Was expecting a block comment close sequence */, but reached the end of the string"
                }
              };
      }
      var match = current2(state);
      var s = match[0];
      switch (s) {
        case "*" :
            if (match[1] === "/") {
              skip(state, 1);
              return {
                      TAG: /* Ok */0,
                      _0: {
                        NAME: "BlockComment",
                        VAL: acc
                      }
                    };
            }
            break;
        case "/" :
            if (match[1] === "*") {
              skip(state, 2);
              var err = loop("");
              if (err.TAG !== /* Ok */0) {
                return err;
              }
              var match$1 = err._0;
              if (typeof match$1 !== "object") {
                return err;
              }
              if (match$1.NAME !== "BlockComment") {
                return err;
              }
              skip(state, 1);
              _acc = acc + "/*" + match$1.VAL + "*/";
              continue ;
            }
            break;
        default:
          
      }
      skip(state, 1);
      _acc = acc + s;
      continue ;
    };
  };
  return loop("");
}

function isValidIdentifierCh(ch) {
  if (ch.length !== 1) {
    return false;
  }
  var match = ch.charCodeAt(0);
  if (match >= 91) {
    if (match >= 97) {
      return match < 123;
    } else {
      return match === 95;
    }
  } else if (match >= 58) {
    return match >= 65;
  } else {
    return match >= 48;
  }
}

function parseParameter(state) {
  skip(state, 1);
  var nameStart = state.pos;
  skipUntil(state, (function (x) {
          return !isValidIdentifierCh(x);
        }));
  if (nameStart === state.pos) {
    return {
            TAG: /* Error */1,
            _0: {
              TAG: /* AutoLocation */1,
              _0: "Unexpected : symbol not followed by a parameter name. If you meant to simply insert :, please escape it with a backslash \\:"
            }
          };
  }
  var name = cutStr(state, nameStart, state.pos - 1 | 0);
  if (at(state, state.pos + 0 | 0) === ":" && at(state, state.pos + 1 | 0) === "r" && at(state, state.pos + 2 | 0) === "a" && at(state, state.pos + 3 | 0) === "w" && at(state, state.pos + 4 | 0) === "<") {
    skip(state, 4);
    var seqStart = state.pos;
    skipUntil(state, (function (x) {
            return x !== "<";
          }));
    var seqLen = state.pos - seqStart | 0;
    var items = [];
    var addItem = function (start) {
      items.push(cutStr(state, start, (state.pos - seqLen | 0) - 1 | 0));
      
    };
    var _itemStart = state.pos;
    var _delCount = 0;
    var _closeCount = 0;
    while(true) {
      var closeCount = _closeCount;
      var delCount = _delCount;
      var itemStart = _itemStart;
      if (closeCount === seqLen) {
        addItem(itemStart);
        back(state, 1);
        return {
                TAG: /* Ok */0,
                _0: {
                  NAME: "RawParameter",
                  VAL: {
                    name: name,
                    options: items
                  }
                }
              };
      }
      if (delCount === seqLen) {
        addItem(itemStart);
        _closeCount = 0;
        _delCount = 0;
        _itemStart = state.pos;
        continue ;
      }
      if (end(state)) {
        var seq = ">".repeat(seqLen);
        return {
                TAG: /* Error */1,
                _0: {
                  TAG: /* AutoLocationStart */2,
                  _0: "Was expecting a raw parameter close sequence " + seq + ", but reached the end of the string"
                }
              };
      }
      var match = at(state, state.pos);
      switch (match) {
        case ">" :
            skip(state, 1);
            _closeCount = closeCount + 1 | 0;
            _delCount = 0;
            continue ;
        case "|" :
            skip(state, 1);
            _closeCount = 0;
            _delCount = delCount + 1 | 0;
            continue ;
        default:
          skip(state, 1);
          _closeCount = 0;
          _delCount = 0;
          continue ;
      }
    };
  } else if (at(state, state.pos + 0 | 0) === ":" && at(state, state.pos + 1 | 0) === "b" && at(state, state.pos + 2 | 0) === "a" && at(state, state.pos + 3 | 0) === "t" && at(state, state.pos + 4 | 0) === "c" && at(state, state.pos + 5 | 0) === "h" && at(state, state.pos + 6 | 0) === "<") {
    skip(state, 6);
    var seqStart$1 = state.pos;
    skipUntil(state, (function (x) {
            return x !== "<";
          }));
    var seqLen$1 = state.pos - seqStart$1 | 0;
    var skipBody = function (_count) {
      while(true) {
        var count = _count;
        if (count === seqLen$1) {
          return {
                  TAG: /* Ok */0,
                  _0: undefined
                };
        }
        if (end(state)) {
          var seq = ">".repeat(seqLen$1);
          return {
                  TAG: /* Error */1,
                  _0: "Was expecting a batch parameter close sequence " + seq + ", but reached the end of the string"
                };
        }
        var match = at(state, state.pos);
        if (match === ">") {
          skip(state, 1);
          _count = count + 1 | 0;
          continue ;
        }
        skip(state, 1);
        _count = 0;
        continue ;
      };
    };
    var bodyStart = state.pos;
    var message = skipBody(0);
    if (message.TAG !== /* Ok */0) {
      return {
              TAG: /* Error */1,
              _0: {
                TAG: /* AutoLocationStart */2,
                _0: message._0
              }
            };
    }
    back(state, 1);
    var ast = toAst(state.symbols, bodyStart, state.pos - seqLen$1 | 0);
    if (ast.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: {
                NAME: "BatchParameter",
                VAL: {
                  name: name,
                  separator: ",",
                  body: ast._0
                }
              }
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: {
                TAG: /* WithLocation */0,
                _0: ast._0
              }
            };
    }
  } else {
    back(state, 1);
    return {
            TAG: /* Ok */0,
            _0: {
              NAME: "Parameter",
              VAL: {
                name: name
              }
            }
          };
  }
}

function toAst(symbols, min, max) {
  var state = {
    symbols: symbols,
    minPos: min,
    maxPos: max,
    pos: min
  };
  var ast = [];
  var sqlChunkStart = {
    contents: undefined
  };
  var sqlChunkVal = {
    contents: ""
  };
  var pushSqlNode = function (param) {
    var start = sqlChunkStart.contents;
    if (start !== undefined) {
      ast.push({
            start: start,
            end: state.pos - 1 | 0,
            node: {
              NAME: "SqlChunk",
              VAL: sqlChunkVal.contents
            }
          });
      sqlChunkVal.contents = "";
      sqlChunkStart.contents = undefined;
      return ;
    }
    
  };
  var pushSqlSymbol = function (symbol) {
    if (sqlChunkStart.contents === undefined) {
      sqlChunkStart.contents = state.pos;
    }
    sqlChunkVal.contents = sqlChunkVal.contents + symbol;
    return skip(state, 1);
  };
  var error = {
    contents: undefined
  };
  var parseWith = function (parser) {
    pushSqlNode(undefined);
    var start = state.pos;
    var node = Curry._1(parser, state);
    if (node.TAG === /* Ok */0) {
      ast.push({
            start: start,
            end: state.pos,
            node: node._0
          });
      return skip(state, 1);
    }
    var message = node._0;
    switch (message.TAG | 0) {
      case /* WithLocation */0 :
          error.contents = message._0;
          return ;
      case /* AutoLocation */1 :
          error.contents = {
            start: start,
            end: state.pos,
            message: message._0
          };
          return ;
      case /* AutoLocationStart */2 :
          error.contents = {
            start: state.pos,
            end: null,
            message: message._0
          };
          return ;
      
    }
  };
  while(!end(state) && error.contents === undefined) {
    var match = current2(state);
    var s = match[0];
    switch (s) {
      case "-" :
          if (match[1] === "-") {
            parseWith(parseInlineComment);
          } else {
            pushSqlSymbol(s);
          }
          break;
      case "/" :
          if (match[1] === "*") {
            parseWith(parseBlockComment);
          } else {
            pushSqlSymbol(s);
          }
          break;
      case ":" :
          parseWith(parseParameter);
          break;
      case "\\" :
          if (match[1] === ":") {
            pushSqlSymbol(":");
            skip(state, 1);
          } else {
            pushSqlSymbol(s);
          }
          break;
      default:
        pushSqlSymbol(s);
    }
  };
  var err = error.contents;
  if (err !== undefined) {
    return {
            TAG: /* Error */1,
            _0: err
          };
  } else {
    pushSqlNode(undefined);
    return {
            TAG: /* Ok */0,
            _0: ast
          };
  }
}

function parseAttribute(text, id) {
  var result = new RegExp("^\\s*\\*?\\s*@" + id + ":\\s*(.*?)\\s*$", "m").exec(text);
  if (result === null) {
    return ;
  }
  var str = result[1];
  if (!(str == null)) {
    return str;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Parser.res",
          321,
          14
        ],
        Error: new Error()
      };
}

function parseAttributes(ast) {
  var _i = 0;
  while(true) {
    var i = _i;
    if (i >= ast.length) {
      return {
              TAG: /* Ok */0,
              _0: {
                name: null
              }
            };
    }
    var match = ast[i];
    var match$1 = match.node;
    if (typeof match$1 !== "object") {
      return {
              TAG: /* Ok */0,
              _0: {
                name: null
              }
            };
    }
    var variant = match$1.NAME;
    if (variant === "BlockComment" || variant === "InlineComment") {
      var value = parseAttribute(match$1.VAL, "name");
      if (value !== undefined) {
        if (/^[a-zA-Z][0-9a-zA-Z_]*$/.test(value)) {
          return {
                  TAG: /* Ok */0,
                  _0: {
                    name: value
                  }
                };
        } else {
          return {
                  TAG: /* Error */1,
                  _0: {
                    start: match.start,
                    end: match.end,
                    message: "Invalid @name attribute: " + value
                  }
                };
        }
      }
      _i = i + 1 | 0;
      continue ;
    }
    if (variant !== "SqlChunk") {
      return {
              TAG: /* Ok */0,
              _0: {
                name: null
              }
            };
    }
    if (match$1.VAL.trim() !== "") {
      return {
              TAG: /* Ok */0,
              _0: {
                name: null
              }
            };
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function findDuplicateParameter(_index, _seen, ast) {
  while(true) {
    var seen = _seen;
    var index = _index;
    if (index >= ast.length) {
      return ;
    }
    var node = ast[index];
    var match = node.node;
    if (typeof match === "object") {
      var variant = match.NAME;
      if (variant === "BatchParameter") {
        var match$1 = match.VAL;
        var name = match$1.name;
        if (seen.includes(name)) {
          return node;
        }
        var some = findDuplicateParameter(0, [], match$1.body);
        if (some !== undefined) {
          return some;
        }
        _seen = seen.concat([name]);
        _index = index + 1 | 0;
        continue ;
      }
      if (variant === "RawParameter" || variant === "Parameter") {
        var name$1 = match.VAL.name;
        if (seen.includes(name$1)) {
          return node;
        }
        _seen = seen.concat([name$1]);
        _index = index + 1 | 0;
        continue ;
      }
      _index = index + 1 | 0;
      continue ;
    }
    _index = index + 1 | 0;
    continue ;
  };
}

function parseSymbols(symbols, start, end) {
  var err = toAst(symbols, start, end);
  if (err.TAG !== /* Ok */0) {
    return err;
  }
  var ast = err._0;
  var match = findDuplicateParameter(0, [], ast);
  if (match !== undefined) {
    var match$1 = match.node;
    if (typeof match$1 === "object") {
      var variant = match$1.NAME;
      if (variant === "RawParameter" || variant === "Parameter" || variant === "BatchParameter") {
        return {
                TAG: /* Error */1,
                _0: {
                  start: match.start,
                  end: match.end,
                  message: "The name \"" + match$1.VAL.name + "\" is already used for another parameter"
                }
              };
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "Parser.res",
              390,
              17
            ],
            Error: new Error()
          };
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Parser.res",
            390,
            17
          ],
          Error: new Error()
        };
  }
  var err$1 = parseAttributes(ast);
  if (err$1.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: {
              attributes: err$1._0,
              ast: ast
            }
          };
  } else {
    return err$1;
  }
}

function parse(text) {
  var symbols = Array.from(text);
  return parseSymbols(symbols, 0, symbols.length - 1 | 0);
}

function parseFile(text) {
  var symbols = Array.from(text);
  var state = {
    symbols: symbols,
    minPos: 0,
    maxPos: symbols.length - 1 | 0,
    pos: 0
  };
  var parseComment = function (parser) {
    var start = state.pos;
    var match = Curry._1(parser, state);
    if (match.TAG === /* Ok */0) {
      var match$1 = match._0;
      if (typeof match$1 === "object") {
        var variant = match$1.NAME;
        if (variant === "BlockComment" || variant === "InlineComment") {
          var res = parseAttribute(match$1.VAL, "separator");
          if (res !== undefined) {
            if (res === "") {
              return {
                      TAG: /* Error */1,
                      _0: {
                        start: start,
                        end: state.pos,
                        message: "Invalid empty @separator attribute"
                      }
                    };
            } else {
              return {
                      TAG: /* Ok */0,
                      _0: res
                    };
            }
          } else {
            return {
                    TAG: /* Ok */0,
                    _0: undefined
                  };
          }
        }
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "Parser.res",
                429,
                15
              ],
              Error: new Error()
            };
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "Parser.res",
              429,
              15
            ],
            Error: new Error()
          };
    }
    var message = match._0;
    switch (message.TAG | 0) {
      case /* WithLocation */0 :
          return {
                  TAG: /* Error */1,
                  _0: message._0
                };
      case /* AutoLocation */1 :
          return {
                  TAG: /* Error */1,
                  _0: {
                    start: start,
                    end: state.pos,
                    message: message._0
                  }
                };
      case /* AutoLocationStart */2 :
          return {
                  TAG: /* Error */1,
                  _0: {
                    start: state.pos,
                    end: null,
                    message: message._0
                  }
                };
      
    }
  };
  var findSeparatorAttribute = function (_param) {
    while(true) {
      if (end(state)) {
        return {
                TAG: /* Ok */0,
                _0: undefined
              };
      }
      var match = current2(state);
      var symbol = match[0];
      switch (symbol) {
        case "-" :
            if (match[1] === "-") {
              var res = parseComment(parseInlineComment);
              if (res.TAG !== /* Ok */0) {
                return res;
              }
              if (res._0 !== undefined) {
                return res;
              }
              skip(state, 1);
              _param = undefined;
              continue ;
            }
            break;
        case "/" :
            if (match[1] === "*") {
              var res$1 = parseComment(parseBlockComment);
              if (res$1.TAG !== /* Ok */0) {
                return res$1;
              }
              if (res$1._0 !== undefined) {
                return res$1;
              }
              skip(state, 1);
              _param = undefined;
              continue ;
            }
            break;
        default:
          
      }
      if (symbol.trim() !== "") {
        return {
                TAG: /* Ok */0,
                _0: undefined
              };
      }
      skip(state, 1);
      _param = undefined;
      continue ;
    };
  };
  var err = findSeparatorAttribute(undefined);
  if (err.TAG !== /* Ok */0) {
    return err;
  }
  var x = err._0;
  var separator = x !== undefined ? (skip(state, 1), Array.from(x)) : (state.pos = 0, [";"]);
  var isSeparator = function (_i) {
    while(true) {
      var i = _i;
      if (i >= separator.length) {
        return true;
      }
      var pos = state.pos + i | 0;
      if (pos >= state.symbols.length || state.symbols[pos] !== separator[i]) {
        return false;
      }
      _i = i + 1 | 0;
      continue ;
    };
  };
  var statements = [];
  var statementStart = {
    contents: undefined
  };
  var pushStatement = function (param) {
    var start = statementStart.contents;
    if (start === undefined) {
      return ;
    }
    var statement = parseSymbols(state.symbols, start, state.pos - 1 | 0);
    if (statement.TAG !== /* Ok */0) {
      return statement._0;
    }
    statements.push(statement._0);
    statementStart.contents = undefined;
    
  };
  var _param;
  while(true) {
    if (end(state)) {
      var err$1 = pushStatement(undefined);
      if (err$1 !== undefined) {
        return {
                TAG: /* Error */1,
                _0: err$1
              };
      } else {
        return {
                TAG: /* Ok */0,
                _0: {
                  separator: separator.join(""),
                  statements: statements
                }
              };
      }
    }
    if (isSeparator(0)) {
      var err$2 = pushStatement(undefined);
      if (err$2 !== undefined) {
        return {
                TAG: /* Error */1,
                _0: err$2
              };
      }
      skip(state, separator.length);
      _param = undefined;
      continue ;
    }
    if (statementStart.contents === undefined) {
      statementStart.contents = state.pos;
    }
    skip(state, 1);
    _param = undefined;
    continue ;
  };
}

exports.parse = parse;
exports.parseFile = parseFile;
/* No side effect */
