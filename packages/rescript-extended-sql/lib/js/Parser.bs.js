// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Js_exn = require("rescript/lib/js/js_exn.js");

function checkPos(state) {
  var pos = state.pos;
  var len = state.symbols.length;
  if (state.pos < 0) {
    return Js_exn.raiseError("Position can't be negative: " + pos);
  } else if (state.pos > len) {
    return Js_exn.raiseError("Position can't be greater than the text lenght: " + pos + " > " + len);
  } else {
    return ;
  }
}

function end(state) {
  return state.pos >= state.symbols.length;
}

function at(state, pos) {
  if (pos < state.symbols.length) {
    return state.symbols[pos];
  } else {
    return "";
  }
}

function next(state) {
  state.pos = state.pos + 1 | 0;
  return checkPos(state);
}

function back(state, offset) {
  state.pos = state.pos - offset | 0;
  return checkPos(state);
}

function skip(state, offset) {
  state.pos = state.pos + offset | 0;
  return checkPos(state);
}

function current2(state) {
  return [
          at(state, state.pos),
          at(state, state.pos + 1 | 0)
        ];
}

function skipUntil(state, fn) {
  while(state.pos < state.symbols.length && !fn(state.symbols[state.pos])) {
    next(state);
  };
  
}

function cutStr(state, start, end) {
  return state.symbols.slice(start, end + 1 | 0).join("");
}

function parseInlineComment(state) {
  skip(state, 2);
  var start = state.pos;
  skipUntil(state, (function (x) {
          return x === "\n";
        }));
  back(state, 1);
  return {
          TAG: /* Ok */0,
          _0: {
            TAG: /* InlineComment */1,
            _0: cutStr(state, start, state.pos)
          }
        };
}

function parseBlockComment(state) {
  skip(state, 2);
  var loop = function (_acc) {
    while(true) {
      var acc = _acc;
      if (end(state)) {
        return {
                TAG: /* Error */1,
                _0: "Was expecting a block comment close sequence */, but reached the end of the string"
              };
      }
      var match = current2(state);
      var s = match[0];
      switch (s) {
        case "*" :
            if (match[1] === "/") {
              next(state);
              return {
                      TAG: /* Ok */0,
                      _0: {
                        TAG: /* BlockComment */2,
                        _0: acc
                      }
                    };
            }
            break;
        case "/" :
            if (match[1] === "*") {
              skip(state, 2);
              var err = loop("");
              if (err.TAG !== /* Ok */0) {
                return err;
              }
              var content = err._0;
              if (content.TAG !== /* BlockComment */2) {
                return err;
              }
              next(state);
              _acc = acc + "/*" + content._0 + "*/";
              continue ;
            }
            break;
        default:
          
      }
      next(state);
      _acc = acc + s;
      continue ;
    };
  };
  return loop("");
}

function isValidIdentifierCh(ch) {
  if (ch.length !== 1) {
    return false;
  }
  var match = ch.charCodeAt(0);
  if (match >= 91) {
    if (match >= 97) {
      return match < 123;
    } else {
      return match === 95;
    }
  } else if (match >= 58) {
    return match >= 65;
  } else {
    return match >= 48;
  }
}

function parseParameter(state) {
  skip(state, 1);
  var nameStart = state.pos;
  skipUntil(state, (function (x) {
          return !isValidIdentifierCh(x);
        }));
  if (nameStart === state.pos) {
    return {
            TAG: /* Error */1,
            _0: "Unexpected : symbol not followed by a parameter name. If you meant to simply insert :, please escape it with a backslash \\:"
          };
  }
  var name = cutStr(state, nameStart, state.pos - 1 | 0);
  if (at(state, state.pos + 0 | 0) === ":" && at(state, state.pos + 1 | 0) === "r" && at(state, state.pos + 2 | 0) === "a" && at(state, state.pos + 3 | 0) === "w" && at(state, state.pos + 4 | 0) === "<") {
    skip(state, 4);
    var seqStart = state.pos;
    skipUntil(state, (function (x) {
            return x !== "<";
          }));
    var seqLen = state.pos - seqStart | 0;
    var items = [];
    var addItem = function (start) {
      items.push(cutStr(state, start, (state.pos - seqLen | 0) - 1 | 0));
      
    };
    var _itemStart = state.pos;
    var _delCount = 0;
    var _closeCount = 0;
    while(true) {
      var closeCount = _closeCount;
      var delCount = _delCount;
      var itemStart = _itemStart;
      if (closeCount === seqLen) {
        addItem(itemStart);
        back(state, 1);
        return {
                TAG: /* Ok */0,
                _0: {
                  TAG: /* RawParameter */4,
                  _0: name,
                  _1: items
                }
              };
      }
      if (delCount === seqLen) {
        addItem(itemStart);
        _closeCount = 0;
        _delCount = 0;
        _itemStart = state.pos;
        continue ;
      }
      if (end(state)) {
        var seq = ">".repeat(seqLen);
        return {
                TAG: /* Error */1,
                _0: "Was expecting a raw parameter close sequence " + seq + ", but reached the end of the string"
              };
      }
      var match = at(state, state.pos);
      switch (match) {
        case ">" :
            next(state);
            _closeCount = closeCount + 1 | 0;
            _delCount = 0;
            continue ;
        case "|" :
            next(state);
            _closeCount = 0;
            _delCount = delCount + 1 | 0;
            continue ;
        default:
          next(state);
          _closeCount = 0;
          _delCount = 0;
          continue ;
      }
    };
  } else if (at(state, state.pos + 0 | 0) === ":" && at(state, state.pos + 1 | 0) === "b" && at(state, state.pos + 2 | 0) === "a" && at(state, state.pos + 3 | 0) === "t" && at(state, state.pos + 4 | 0) === "c" && at(state, state.pos + 5 | 0) === "h" && at(state, state.pos + 6 | 0) === "<") {
    skip(state, 6);
    var seqStart$1 = state.pos;
    skipUntil(state, (function (x) {
            return x !== "<";
          }));
    var seqLen$1 = state.pos - seqStart$1 | 0;
    var skipBody = function (_count) {
      while(true) {
        var count = _count;
        if (count === seqLen$1) {
          return {
                  TAG: /* Ok */0,
                  _0: undefined
                };
        }
        if (end(state)) {
          var seq = ">".repeat(seqLen$1);
          return {
                  TAG: /* Error */1,
                  _0: "Was expecting a batch parameter close sequence " + seq + ", but reached the end of the string"
                };
        }
        var match = at(state, state.pos);
        if (match === ">") {
          next(state);
          _count = count + 1 | 0;
          continue ;
        }
        next(state);
        _count = 0;
        continue ;
      };
    };
    var bodyStart = state.pos;
    var err = skipBody(0);
    if (err.TAG !== /* Ok */0) {
      return err;
    }
    back(state, 1);
    var ast = toAst(cutStr(state, bodyStart, state.pos - seqLen$1 | 0));
    if (ast.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: {
                TAG: /* BatchParameter */5,
                _0: name,
                _1: ",",
                _2: ast._0
              }
            };
    }
    var match$1 = ast._0;
    state.pos = bodyStart + match$1.pos | 0;
    return {
            TAG: /* Error */1,
            _0: match$1.message
          };
  } else {
    back(state, 1);
    return {
            TAG: /* Ok */0,
            _0: {
              TAG: /* Parameter */3,
              _0: name
            }
          };
  }
}

function toAst(text) {
  var state = {
    symbols: Array.from(text),
    pos: 0
  };
  var ast = [];
  var currentSQLChunk = {
    contents: ""
  };
  var commitSQLChunk = function (param) {
    if (currentSQLChunk.contents !== "") {
      ast.push({
            TAG: /* SQL_Chunk */0,
            _0: currentSQLChunk.contents
          });
      currentSQLChunk.contents = "";
      return ;
    }
    
  };
  var subParse = function (parser) {
    commitSQLChunk(undefined);
    var node = Curry._1(parser, state);
    if (node.TAG !== /* Ok */0) {
      return {
              TAG: /* Error */1,
              _0: {
                message: node._0,
                pos: state.pos
              }
            };
    }
    ast.push(node._0);
    next(state);
    return loop(undefined);
  };
  var loop = function (_param) {
    while(true) {
      if (end(state)) {
        commitSQLChunk(undefined);
        return {
                TAG: /* Ok */0,
                _0: undefined
              };
      }
      var match = current2(state);
      var s = match[0];
      switch (s) {
        case "-" :
            if (match[1] === "-") {
              return subParse(parseInlineComment);
            }
            break;
        case "/" :
            if (match[1] === "*") {
              return subParse(parseBlockComment);
            }
            break;
        case ":" :
            return subParse(parseParameter);
        case "\\" :
            if (match[1] === ":") {
              skip(state, 2);
              currentSQLChunk.contents = currentSQLChunk.contents + ":";
              _param = undefined;
              continue ;
            }
            break;
        default:
          
      }
      next(state);
      currentSQLChunk.contents = currentSQLChunk.contents + s;
      _param = undefined;
      continue ;
    };
  };
  var err = loop(undefined);
  if (err.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: ast
          };
  } else {
    return err;
  }
}

function commentsBeforeCode(_i, _acc, ast) {
  while(true) {
    var acc = _acc;
    var i = _i;
    if (i >= ast.length) {
      return acc;
    }
    var str = ast[i];
    switch (str.TAG | 0) {
      case /* SQL_Chunk */0 :
          if (str._0.trim() !== "") {
            return acc;
          }
          _i = i + 1 | 0;
          continue ;
      case /* InlineComment */1 :
      case /* BlockComment */2 :
          break;
      default:
        return acc;
    }
    _acc = acc + "\n" + str._0;
    _i = i + 1 | 0;
    continue ;
  };
}

function parseAttributes(ast) {
  var result = /^\s*@name:\s*(.*?)\s*$/m.exec(commentsBeforeCode(0, "", ast));
  var name;
  if (result !== null) {
    var value = result[1];
    name = (value == null) ? ({
          TAG: /* Error */1,
          _0: "Invalid @name attribute"
        }) : (
        /^[a-zA-Z][0-9a-zA-Z_]*$/.test(value) ? ({
              TAG: /* Ok */0,
              _0: value
            }) : ({
              TAG: /* Error */1,
              _0: "Invalid @name attribute: " + value
            })
      );
  } else {
    name = {
      TAG: /* Ok */0,
      _0: undefined
    };
  }
  if (name.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: {
              name: name._0
            }
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: {
              message: name._0,
              pos: -1
            }
          };
  }
}

function parse(text) {
  var err = toAst(text);
  if (err.TAG !== /* Ok */0) {
    return err;
  }
  var ast = err._0;
  var err$1 = parseAttributes(ast);
  if (err$1.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: {
              attributes: err$1._0,
              ast: ast
            }
          };
  } else {
    return err$1;
  }
}

function parseFile(text) {
  var err = toAst(text);
  if (err.TAG !== /* Ok */0) {
    return err;
  }
  var result = /^\s*@separator:\s*(.*?)\s*$/m.exec(commentsBeforeCode(0, "", err._0));
  var tmp;
  if (result !== null) {
    var value = result[1];
    if (value == null) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "Parser.res",
              401,
              18
            ],
            Error: new Error()
          };
    }
    tmp = value;
  } else {
    tmp = ";";
  }
  var texts = text.split(tmp);
  var _acc = [];
  var _i = 0;
  while(true) {
    var i = _i;
    var acc = _acc;
    if (i >= texts.length) {
      return {
              TAG: /* Ok */0,
              _0: acc.filter(function (parsed) {
                    return parsed.ast.some(function (node) {
                                switch (node.TAG | 0) {
                                  case /* SQL_Chunk */0 :
                                      return node._0.trim() !== "";
                                  case /* InlineComment */1 :
                                  case /* BlockComment */2 :
                                      return false;
                                  default:
                                    return true;
                                }
                              });
                  })
            };
    }
    var parsed = parse(texts[i].trim());
    if (parsed.TAG !== /* Ok */0) {
      return parsed;
    }
    _i = i + 1 | 0;
    _acc = acc.concat([parsed._0]);
    continue ;
  };
}

exports.parse = parse;
exports.parseFile = parseFile;
/* No side effect */
