// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_array = require("rescript/lib/js/caml_array.js");

function inRange(arr, pos) {
  return pos < arr.length;
}

function nextEq(arr, pos, val) {
  if ((pos + 1 | 0) < arr.length) {
    return arr[pos + 1 | 0] === val;
  } else {
    return false;
  }
}

function parseInlineComment(param, param$1) {
  var _acc = "";
  var _startPos = param$1;
  while(true) {
    var startPos = _startPos;
    var acc = _acc;
    if (startPos >= param.length) {
      return {
              TAG: /* Ok */0,
              _0: [
                startPos,
                {
                  TAG: /* InlineComment */2,
                  _0: acc
                }
              ]
            };
    }
    var s = param[startPos];
    if (s === "\n") {
      return {
              TAG: /* Ok */0,
              _0: [
                startPos + 1 | 0,
                {
                  TAG: /* InlineComment */2,
                  _0: acc
                }
              ]
            };
    }
    _startPos = startPos + 1 | 0;
    _acc = acc + s;
    continue ;
  };
}

function parseBlockComment(_acc, symbols, _startPos) {
  while(true) {
    var startPos = _startPos;
    var acc = _acc;
    if (startPos >= symbols.length) {
      return {
              TAG: /* Error */1,
              _0: {
                message: "Was expecting a block comment close sequence */, but reached the end of the string",
                pos: startPos
              }
            };
    }
    var s = symbols[startPos];
    switch (s) {
      case "*" :
          if (nextEq(symbols, startPos, "/")) {
            return {
                    TAG: /* Ok */0,
                    _0: [
                      startPos + 2 | 0,
                      {
                        TAG: /* BlockComment */3,
                        _0: acc
                      }
                    ]
                  };
          }
          break;
      case "/" :
          if (nextEq(symbols, startPos, "*")) {
            var err = parseBlockComment("", symbols, startPos + 2 | 0);
            if (err.TAG !== /* Ok */0) {
              return err;
            }
            var match = err._0;
            var content = match[1];
            if (content.TAG === /* BlockComment */3) {
              _startPos = match[0];
              _acc = acc + "/*" + content._0 + "*/";
              continue ;
            }
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "Parser.res",
                    52,
                    13
                  ],
                  Error: new Error()
                };
          }
          break;
      default:
        
    }
    _startPos = startPos + 1 | 0;
    _acc = acc + s;
    continue ;
  };
}

function parseBlockComment$1(param, param$1) {
  return parseBlockComment("", param, param$1);
}

function toAst(text) {
  var symbols = Array.from(text);
  var pos = {
    contents: 0
  };
  var ast = [];
  var currentSQLChunk = {
    contents: ""
  };
  var error = {
    contents: undefined
  };
  var commitSQLChunk = function (param) {
    if (currentSQLChunk.contents !== "") {
      ast.push({
            TAG: /* SQL_Chunk */0,
            _0: currentSQLChunk.contents
          });
      currentSQLChunk.contents = "";
      return ;
    }
    
  };
  var commitSubParse = function (result) {
    commitSQLChunk(undefined);
    if (result.TAG !== /* Ok */0) {
      error.contents = result._0;
      return ;
    }
    var match = result._0;
    ast.push(match[1]);
    pos.contents = match[0];
    
  };
  var nextEq$1 = function (val) {
    return nextEq(symbols, pos.contents, val);
  };
  while(error.contents === undefined && pos.contents < symbols.length) {
    var s = symbols[pos.contents];
    var exit = 0;
    switch (s) {
      case "-" :
          if (nextEq$1("-")) {
            commitSubParse(parseInlineComment(symbols, pos.contents + 2 | 0));
          } else {
            exit = 1;
          }
          break;
      case "/" :
          if (nextEq$1("*")) {
            commitSubParse(parseBlockComment$1(symbols, pos.contents + 2 | 0));
          } else {
            exit = 1;
          }
          break;
      default:
        exit = 1;
    }
    if (exit === 1) {
      currentSQLChunk.contents = currentSQLChunk.contents + s;
      pos.contents = pos.contents + 1 | 0;
    }
    
  };
  var err = error.contents;
  if (err !== undefined) {
    return {
            TAG: /* Error */1,
            _0: err
          };
  } else {
    commitSQLChunk(undefined);
    return {
            TAG: /* Ok */0,
            _0: ast
          };
  }
}

function parseAttributes(ast) {
  var allComments = ast.flatMap(function (node) {
          switch (node.TAG | 0) {
            case /* SQL_Chunk */0 :
            case /* Parameter */1 :
                return [];
            case /* InlineComment */2 :
            case /* BlockComment */3 :
                return [node._0];
            
          }
        }).join("\n");
  var result = /@name:(.*)/.exec(allComments);
  var name;
  if (result !== null) {
    var value = result[1];
    if (value == null) {
      name = {
        TAG: /* Error */1,
        _0: "Invalid @name attribute"
      };
    } else {
      var trimmed = value.trim();
      name = /^[a-zA-Z][0-9a-zA-Z_]*$/.test(trimmed) ? ({
            TAG: /* Ok */0,
            _0: trimmed
          }) : ({
            TAG: /* Error */1,
            _0: "Invalid @name attribute: " + trimmed
          });
    }
  } else {
    name = {
      TAG: /* Ok */0,
      _0: undefined
    };
  }
  if (name.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: {
              name: name._0
            }
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: {
              message: name._0,
              pos: -1
            }
          };
  }
}

function parse(text) {
  var err = toAst(text);
  if (err.TAG !== /* Ok */0) {
    return err;
  }
  var ast = err._0;
  var err$1 = parseAttributes(ast);
  if (err$1.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: {
              rawText: text,
              attributes: err$1._0,
              ast: ast
            }
          };
  } else {
    return err$1;
  }
}

function isValidIdentifierCh(ch) {
  var code = ch.charCodeAt(0);
  if (code >= 48 && code <= 57 || code >= 65 && code <= 90) {
    return true;
  } else if (code >= 97) {
    return code <= 122;
  } else {
    return false;
  }
}

function parseStatement(text) {
  var parameters = [];
  var commitParameter = function (newText, parameter, nextCh) {
    var index = parameters.push(parameter);
    return [
            newText + "$" + String(index) + nextCh,
            undefined
          ];
  };
  var helper = function (_newText, _state, _pos, _parameter, _name) {
    while(true) {
      var name = _name;
      var parameter = _parameter;
      var pos = _pos;
      var state = _state;
      var newText = _newText;
      var nextCh = text.charAt(pos);
      var match = text.charAt(pos + 1 | 0);
      var state$p;
      if (nextCh === "") {
        state$p = undefined;
      } else {
        switch (state) {
          case /* Code */0 :
              switch (nextCh) {
                case "-" :
                    state$p = match === "-" ? /* InlineComment */1 : state;
                    break;
                case "/" :
                    state$p = match === "*" ? /* BlockComment */2 : state;
                    break;
                default:
                  state$p = state;
              }
              break;
          case /* InlineComment */1 :
              state$p = nextCh === "\n" ? /* Code */0 : state;
              break;
          case /* BlockComment */2 :
              state$p = nextCh === "*" && match === "/" ? /* Code */0 : state;
              break;
          
        }
      }
      var match$1;
      if (parameter !== undefined) {
        match$1 = state$p !== undefined && !(state$p !== 0 || !isValidIdentifierCh(nextCh)) ? [
            newText,
            parameter + nextCh
          ] : commitParameter(newText, parameter, nextCh);
      } else {
        var exit = 0;
        if (state$p !== undefined && !(state$p !== 0 || nextCh !== "$")) {
          match$1 = [
            newText,
            ""
          ];
        } else {
          exit = 1;
        }
        if (exit === 1) {
          match$1 = [
            newText + nextCh,
            undefined
          ];
        }
        
      }
      var newText$p = match$1[0];
      var name$p;
      if (typeof name === "number") {
        if (name === /* Looking */0) {
          var exit$1 = 0;
          if (state$p === 0) {
            name$p = /* NotFound */1;
          } else {
            exit$1 = 1;
          }
          if (exit$1 === 1) {
            name$p = nextCh === "@" ? ({
                  TAG: /* Filling */0,
                  _0: ""
                }) : name;
          }
          
        } else {
          name$p = name;
        }
      } else if (name.TAG === /* Filling */0) {
        var val = name._0;
        name$p = state$p !== undefined && state$p !== 0 && isValidIdentifierCh(nextCh) ? ({
              TAG: /* Filling */0,
              _0: val + nextCh
            }) : ({
              TAG: /* Found */1,
              _0: val
            });
      } else {
        name$p = name;
      }
      if (state$p === undefined) {
        if (typeof name$p === "number" || name$p.TAG !== /* Found */1) {
          return {
                  TAG: /* Error */1,
                  _0: /* NameNotFound */0
                };
        } else {
          return {
                  TAG: /* Ok */0,
                  _0: [
                    name$p._0,
                    newText$p
                  ]
                };
        }
      }
      _name = name$p;
      _parameter = match$1[1];
      _pos = pos + 1 | 0;
      _state = state$p;
      _newText = newText$p;
      continue ;
    };
  };
  var message = helper("", /* Code */0, 0, undefined, /* Looking */0);
  if (message.TAG !== /* Ok */0) {
    return {
            TAG: /* Error */1,
            _0: message._0
          };
  }
  var match = message._0;
  return {
          TAG: /* Ok */0,
          _0: {
            name: match[0],
            parameters: parameters,
            originalStatement: text,
            processedStatement: match[1]
          }
        };
}

function parse$1(text) {
  var statements = text.split(";").map(function (prim) {
          return prim.trim();
        }).filter(function (val) {
        return val !== "";
      });
  var _results = [];
  var _i = 0;
  while(true) {
    var i = _i;
    var results = _results;
    if (i === statements.length) {
      return {
              TAG: /* Ok */0,
              _0: results
            };
    }
    var statement = Caml_array.get(statements, i);
    var res = parseStatement(statement);
    if (res.TAG !== /* Ok */0) {
      return {
              TAG: /* Error */1,
              _0: "The following statement is missing a name declaration. Did you forget to add a \"-- @someName\" comment?\n\n" + statement
            };
    }
    _i = i + 1 | 0;
    _results = results.concat([res._0]);
    continue ;
  };
}

var ParseTMP = {
  A: undefined,
  S: undefined,
  I: undefined,
  isValidIdentifierCh: isValidIdentifierCh,
  parseStatement: parseStatement,
  parse: parse$1
};

exports.inRange = inRange;
exports.nextEq = nextEq;
exports.parseInlineComment = parseInlineComment;
exports.parseBlockComment = parseBlockComment$1;
exports.toAst = toAst;
exports.parseAttributes = parseAttributes;
exports.parse = parse;
exports.ParseTMP = ParseTMP;
/* No side effect */
