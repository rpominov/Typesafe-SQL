// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Curry = require("rescript/lib/js/curry.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Js_json = require("rescript/lib/js/js_json.js");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");
var Promise$TypesafeSqlBuilder = require("./Promise.bs.js");
var DescribeQuery = require("@typesafe-sql/describe-query");

function read(path) {
  return new Promise((function (resolve, reject) {
                Fs.readFile(path, "utf8", (function (err, content) {
                        if (err == null) {
                          if (content !== undefined) {
                            return resolve({
                                        TAG: /* Ok */0,
                                        _0: content
                                      });
                          } else {
                            return resolve({
                                        TAG: /* Ok */0,
                                        _0: ""
                                      });
                          }
                        }
                        var msg = err.message;
                        return resolve({
                                    TAG: /* Error */1,
                                    _0: msg !== undefined ? msg : String(err)
                                  });
                      }));
                
              }));
}

var Read = {
  read: read
};

function isValidIdentifierCh(ch) {
  var code = ch.charCodeAt(0);
  if (code >= 48 && code <= 57 || code >= 65 && code <= 90) {
    return true;
  } else if (code >= 97) {
    return code <= 122;
  } else {
    return false;
  }
}

function parseStatement(text) {
  var parameters = [];
  var commitParameter = function (newText, parameter, nextCh) {
    var index = parameters.push(parameter);
    return [
            newText + "$" + index.toString() + nextCh,
            undefined
          ];
  };
  var helper = function (_newText, _state, _pos, _parameter, _name) {
    while(true) {
      var name = _name;
      var parameter = _parameter;
      var pos = _pos;
      var state = _state;
      var newText = _newText;
      var nextCh = text.charAt(pos);
      var match = text.charAt(pos + 1 | 0);
      var state$p;
      if (nextCh === "") {
        state$p = undefined;
      } else {
        switch (state) {
          case /* Code */0 :
              switch (nextCh) {
                case "-" :
                    state$p = match === "-" ? /* InlineComment */1 : state;
                    break;
                case "/" :
                    state$p = match === "*" ? /* BlockComment */2 : state;
                    break;
                default:
                  state$p = state;
              }
              break;
          case /* InlineComment */1 :
              state$p = nextCh === "\n" ? /* Code */0 : state;
              break;
          case /* BlockComment */2 :
              state$p = nextCh === "*" && match === "/" ? /* Code */0 : state;
              break;
          
        }
      }
      var match$1;
      if (parameter !== undefined) {
        match$1 = state$p !== undefined && !(state$p !== 0 || !isValidIdentifierCh(nextCh)) ? [
            newText,
            parameter + nextCh
          ] : commitParameter(newText, parameter, nextCh);
      } else {
        var exit = 0;
        if (state$p !== undefined && !(state$p !== 0 || nextCh !== "$")) {
          match$1 = [
            newText,
            ""
          ];
        } else {
          exit = 1;
        }
        if (exit === 1) {
          match$1 = [
            newText + nextCh,
            undefined
          ];
        }
        
      }
      var newText$p = match$1[0];
      var name$p;
      if (typeof name === "number") {
        if (name === /* Looking */0) {
          var exit$1 = 0;
          if (state$p === 0) {
            name$p = /* NotFound */1;
          } else {
            exit$1 = 1;
          }
          if (exit$1 === 1) {
            name$p = nextCh === "@" ? ({
                  TAG: /* Filling */0,
                  _0: ""
                }) : name;
          }
          
        } else {
          name$p = name;
        }
      } else if (name.TAG === /* Filling */0) {
        var val = name._0;
        name$p = state$p !== undefined && state$p !== 0 && isValidIdentifierCh(nextCh) ? ({
              TAG: /* Filling */0,
              _0: val + nextCh
            }) : ({
              TAG: /* Found */1,
              _0: val
            });
      } else {
        name$p = name;
      }
      if (state$p === undefined) {
        if (typeof name$p === "number" || name$p.TAG !== /* Found */1) {
          return {
                  TAG: /* Error */1,
                  _0: /* NameNotFound */0
                };
        } else {
          return {
                  TAG: /* Ok */0,
                  _0: [
                    name$p._0,
                    newText$p
                  ]
                };
        }
      }
      _name = name$p;
      _parameter = match$1[1];
      _pos = pos + 1 | 0;
      _state = state$p;
      _newText = newText$p;
      continue ;
    };
  };
  var message = helper("", /* Code */0, 0, undefined, /* Looking */0);
  if (message.TAG !== /* Ok */0) {
    return {
            TAG: /* Error */1,
            _0: message._0
          };
  }
  var match = message._0;
  return {
          TAG: /* Ok */0,
          _0: {
            name: match[0],
            parameters: parameters,
            originalStatement: text,
            processedStatement: match[1]
          }
        };
}

function parse(text) {
  var statements = text.split(";").map(function (prim) {
          return prim.trim();
        }).filter(function (val) {
        return val !== "";
      });
  var _results = [];
  var _i = 0;
  while(true) {
    var i = _i;
    var results = _results;
    if (i === statements.length) {
      return {
              TAG: /* Ok */0,
              _0: results
            };
    }
    var statement = Caml_array.get(statements, i);
    var res = parseStatement(statement);
    if (res.TAG !== /* Ok */0) {
      return {
              TAG: /* Error */1,
              _0: "The following statement is missing a name declaration. Did you forget to add a \"-- @someName\" comment?\n\n" + statement
            };
    }
    _i = i + 1 | 0;
    _results = results.concat([res._0]);
    continue ;
  };
}

var Parse = {
  isValidIdentifierCh: isValidIdentifierCh,
  parseStatement: parseStatement,
  parse: parse
};

function highlight(code, position) {
  var lines = code.split("\n");
  var newLines = [];
  var helper = function (_i, _pos) {
    while(true) {
      var pos = _pos;
      var i = _i;
      if (i === lines.length) {
        return ;
      }
      var line = Caml_array.get(lines, i);
      newLines.push(line);
      var pos$p = (pos - line.length | 0) - 1 | 0;
      if (pos > 0 && pos$p <= 0) {
        newLines.push(" ".repeat(pos - 1 | 0) + "^");
      }
      _pos = pos$p;
      _i = i + 1 | 0;
      continue ;
    };
  };
  helper(0, position);
  return newLines.join("\n");
}

function errorToString(exn, statement) {
  var jsExn = Caml_js_exceptions.caml_as_js_exn(exn);
  var match;
  if (jsExn !== undefined) {
    var jsExn$1 = Caml_option.valFromOption(jsExn);
    var dbe = DescribeQuery.getErrorMetaData(jsExn$1).databaseError;
    if (dbe !== undefined) {
      var dbe$1 = Caml_option.valFromOption(dbe);
      match = [
        DescribeQuery.getVerboseMessage(dbe$1),
        dbe$1.position
      ];
    } else {
      var message = jsExn$1.message;
      match = message !== undefined ? [
          message,
          undefined
        ] : [
          String(exn),
          undefined
        ];
    }
  } else {
    match = [
      String(exn),
      undefined
    ];
  }
  var p = Belt_Option.flatMap(match[1], Belt_Int.fromString);
  var statement$p = p !== undefined ? highlight(statement, p) : statement;
  return "Database server could not process the following statement:\n\n" + statement$p + "\n\n" + match[0];
}

function describe(client, text) {
  return Promise$TypesafeSqlBuilder.chain(client.describe(text), (function (val) {
                var tmp;
                tmp = val.TAG === /* Ok */0 ? ({
                      TAG: /* Ok */0,
                      _0: val._0
                    }) : ({
                      TAG: /* Error */1,
                      _0: errorToString(val._0, text)
                    });
                return Promise.resolve(tmp);
              }));
}

function describeMany(client, texts) {
  var helper = function (result, i) {
    if (i === texts.length) {
      return result;
    } else {
      return Promise$TypesafeSqlBuilder.chainOk(result, (function (val) {
                    if (val.TAG !== /* Ok */0) {
                      return Promise.resolve({
                                  TAG: /* Error */1,
                                  _0: val._0
                                });
                    }
                    var result$p = val._0;
                    return helper(Promise$TypesafeSqlBuilder.chainOk(describe(client, Caml_array.get(texts, i)), (function (val) {
                                      var tmp;
                                      tmp = val.TAG === /* Ok */0 ? ({
                                            TAG: /* Ok */0,
                                            _0: result$p.concat([val._0])
                                          }) : ({
                                            TAG: /* Error */1,
                                            _0: val._0
                                          });
                                      return Promise.resolve(tmp);
                                    })), i + 1 | 0);
                  }));
    }
  };
  return helper(Promise.resolve({
                  TAG: /* Ok */0,
                  _0: []
                }), 0);
}

var Describe = {
  highlight: highlight,
  errorToString: errorToString,
  describe: describe,
  describeMany: describeMany
};

function compose(parsed, described) {
  if (parsed.length !== described.length) {
    Js_exn.raiseError("Parsed / described mismatch (queries count)");
  }
  return Belt_Array.zipBy(parsed, described, (function (p, d) {
                if (p.parameters.length !== d.input.length) {
                  Js_exn.raiseError("Parsed / described mismatch (parameters count)");
                }
                return {
                        name: p.name,
                        originalStatement: p.originalStatement,
                        processedStatement: p.processedStatement,
                        parameters: Belt_Array.zipBy(p.parameters, d.input, (function (name, data) {
                                return {
                                        name: name,
                                        datatype: data.type
                                      };
                              })),
                        columns: d.output
                      };
              }));
}

function generate(parsed, described, generator) {
  return Promise$TypesafeSqlBuilder.chain(Promise$TypesafeSqlBuilder.chainOk(Promise.resolve(undefined), (function (param) {
                    return Curry._1(generator, compose(parsed, described));
                  })), (function (val) {
                var tmp;
                if (val.TAG === /* Ok */0) {
                  tmp = {
                    TAG: /* Ok */0,
                    _0: val._0
                  };
                } else {
                  var exn = val._0;
                  var jsExn = Caml_js_exceptions.caml_as_js_exn(exn);
                  var tmp$1;
                  if (jsExn !== undefined) {
                    var jsExn$1 = Caml_option.valFromOption(jsExn);
                    var stack = jsExn$1.stack;
                    if (stack !== undefined) {
                      tmp$1 = stack;
                    } else {
                      var message = jsExn$1.message;
                      tmp$1 = message !== undefined ? message : String(exn);
                    }
                  } else {
                    tmp$1 = String(exn);
                  }
                  tmp = {
                    TAG: /* Error */1,
                    _0: tmp$1
                  };
                }
                return Promise.resolve(tmp);
              }));
}

function jsonGenerator(data) {
  return Promise.resolve(Js_json.serializeExn(data));
}

var Generate = {
  compose: compose,
  generate: generate,
  jsonGenerator: jsonGenerator
};

var Write = {};

var A;

var S;

var O;

var I;

var E;

var DQ;

exports.A = A;
exports.S = S;
exports.O = O;
exports.I = I;
exports.E = E;
exports.DQ = DQ;
exports.Read = Read;
exports.Parse = Parse;
exports.Describe = Describe;
exports.Generate = Generate;
exports.Write = Write;
/* fs Not a pure module */
