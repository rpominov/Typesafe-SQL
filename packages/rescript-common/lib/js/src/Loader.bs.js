// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var $$Promise = require("./Promise.bs.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");

function make(fetcher, keyToKey, valToKey) {
  return {
          cache: {},
          fetcher: fetcher,
          keyToKey: keyToKey,
          valToKey: valToKey,
          quenue: [],
          currentRequestKeys: undefined,
          currentRequestResult: undefined
        };
}

function fetchQuenue(loader) {
  if (loader.currentRequestResult === undefined) {
    if (loader.quenue.length > 0) {
      loader.currentRequestResult = Caml_option.some($$Promise.chain($$Promise.chain($$Promise.resolve(undefined), (function (param) {
                      var keys = loader.quenue;
                      loader.quenue = [];
                      loader.currentRequestKeys = keys;
                      return Curry._1(loader.fetcher, keys);
                    })), (function (values) {
                  var expectedKeys = Belt_Option.getExn(loader.currentRequestKeys);
                  var foundKeys = [];
                  loader.currentRequestKeys = undefined;
                  loader.currentRequestResult = undefined;
                  for(var i = 0 ,i_finish = values.length; i < i_finish; ++i){
                    var val = Caml_array.get(values, i);
                    var keyStr = Curry._1(loader.valToKey, val);
                    foundKeys.push(keyStr);
                    loader.cache["key_" + keyStr] = Caml_option.some(val);
                  }
                  for(var i$1 = 0 ,i_finish$1 = expectedKeys.length; i$1 < i_finish$1; ++i$1){
                    var keyStr$1 = Curry._1(loader.keyToKey, Caml_array.get(expectedKeys, i$1));
                    if (!foundKeys.includes(keyStr$1)) {
                      loader.cache["key_" + keyStr$1] = undefined;
                    }
                    
                  }
                  return $$Promise.resolve(undefined);
                })));
    } else {
      loader.currentRequestResult = Caml_option.some($$Promise.resolve(undefined));
    }
    return ;
  }
  
}

function get(loader, key) {
  var keyStr = Curry._1(loader.keyToKey, key);
  var val = Js_dict.get(loader.cache, "key_" + keyStr);
  if (val !== undefined) {
    return $$Promise.resolve(Caml_option.valFromOption(val));
  } else {
    if (loader.quenue.every(function (k) {
            return Curry._1(loader.keyToKey, k) !== keyStr;
          })) {
      loader.quenue.push(key);
    }
    fetchQuenue(loader);
    return $$Promise.chain(Belt_Option.getExn(loader.currentRequestResult), (function (param) {
                  return get(loader, key);
                }));
  }
}

exports.make = make;
exports.get = get;
/* Promise Not a pure module */
