// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Js_exn = require("rescript/lib/js/js_exn.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_splice_call = require("rescript/lib/js/caml_splice_call.js");

function isZeroWidth(ch) {
  if (ch === "\n") {
    return true;
  } else {
    return false;
  }
}

function highlight(code, start, end) {
  if (start < 0) {
    Js_exn.raiseRangeError("start is out of range: " + start);
  }
  if (end < start) {
    Js_exn.raiseRangeError("end is out of range: " + end);
  }
  var symbols = Array.from(code);
  var result = [];
  var highlightSymbols = [];
  var highlightSymbolsEmpty = true;
  for(var i = 0 ,i_finish = Math.max(symbols.length - 1 | 0, end); i <= i_finish; ++i){
    var symbol = Belt_Array.get(symbols, i);
    if (!isZeroWidth(symbol)) {
      if (i < start) {
        highlightSymbols.push(" ");
      } else if (i <= end) {
        highlightSymbols.push("^");
        highlightSymbolsEmpty = false;
      }
      
    }
    if (symbol !== undefined) {
      result.push(symbol);
    }
    if (symbol === "\n") {
      if (!highlightSymbolsEmpty) {
        Caml_splice_call.spliceObjApply(result, "push", [highlightSymbols]);
        result.push("\n");
      }
      highlightSymbolsEmpty = true;
      highlightSymbols = [];
    }
    
  }
  if (!highlightSymbolsEmpty) {
    result.push("\n");
    Caml_splice_call.spliceObjApply(result, "push", [highlightSymbols]);
  }
  return result.join("");
}

exports.highlight = highlight;
/* No side effect */
