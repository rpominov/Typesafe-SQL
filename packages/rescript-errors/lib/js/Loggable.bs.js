// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Native$Errors = require("./Native.bs.js");
var Caml_splice_call = require("rescript/lib/js/caml_splice_call.js");

function cause(param) {
  return param.cause;
}

function fromText(message) {
  return {
          cause: /* None */0,
          message: [{
              TAG: /* Text */0,
              _0: message
            }]
        };
}

function fromUnknown(obj) {
  return {
          cause: /* None */0,
          message: [{
              TAG: /* Obj */3,
              _0: obj
            }]
        };
}

function fromNative(err) {
  return {
          cause: {
            TAG: /* Native */1,
            _0: err
          },
          message: [{
              TAG: /* MessageOf */1,
              _0: err
            }]
        };
}

function fromNativeVerbose(err) {
  return {
          cause: {
            TAG: /* Native */1,
            _0: err
          },
          message: [{
              TAG: /* StackOf */2,
              _0: err
            }]
        };
}

function fromJsExn(jsExn) {
  var err = Native$Errors.fromJsExn(jsExn);
  if (err !== undefined) {
    return fromNative(Caml_option.valFromOption(err));
  } else {
    return {
            cause: {
              TAG: /* Unknown */2,
              _0: jsExn
            },
            message: [{
                TAG: /* Obj */3,
                _0: jsExn
              }]
          };
  }
}

function fromJsExnVerbose(jsExn) {
  var err = Native$Errors.fromJsExn(jsExn);
  if (err !== undefined) {
    return fromNativeVerbose(Caml_option.valFromOption(err));
  } else {
    return {
            cause: {
              TAG: /* Unknown */2,
              _0: jsExn
            },
            message: [{
                TAG: /* Obj */3,
                _0: jsExn
              }]
          };
  }
}

function fromExn(exn) {
  if (exn.RE_EXN_ID === Js_exn.$$Error) {
    return fromJsExn(exn._1);
  } else {
    return {
            cause: {
              TAG: /* Exn */0,
              _0: exn
            },
            message: [{
                TAG: /* Obj */3,
                _0: exn
              }]
          };
  }
}

function fromExnVerbose(exn) {
  if (exn.RE_EXN_ID === Js_exn.$$Error) {
    return fromJsExnVerbose(exn._1);
  } else {
    return {
            cause: {
              TAG: /* Exn */0,
              _0: exn
            },
            message: [{
                TAG: /* Obj */3,
                _0: exn
              }]
          };
  }
}

function prepend(param, text) {
  return {
          cause: param.cause,
          message: [{
                TAG: /* Text */0,
                _0: text
              }].concat(param.message)
        };
}

function append(param, text) {
  return {
          cause: param.cause,
          message: param.message.concat([{
                  TAG: /* Text */0,
                  _0: text
                }])
        };
}

function toString(param) {
  return param.message.map(function (node) {
                switch (node.TAG | 0) {
                  case /* Text */0 :
                      return node._0;
                  case /* MessageOf */1 :
                      var err = node._0;
                      var x = err.message;
                      if (x === "") {
                        return err.stack;
                      } else {
                        return x;
                      }
                  case /* StackOf */2 :
                      return node._0.stack;
                  case /* Obj */3 :
                      var val = node._0;
                      var str;
                      try {
                        str = JSON.stringify(val);
                      }
                      catch (exn){
                        return String(val);
                      }
                      if (str !== undefined) {
                        return str;
                      } else {
                        return String(val);
                      }
                  
                }
              }).join(" ");
}

function compile(param) {
  return param.message.map(function (node) {
              if (node.TAG !== /* MessageOf */1) {
                return node._0;
              }
              var err = node._0;
              var x = err.message;
              if (x === "") {
                return err;
              } else {
                return x;
              }
            });
}

function log(loggerOpt, loggable) {
  var logger = loggerOpt !== undefined ? loggerOpt : (function (prim) {
        Caml_splice_call.spliceApply(console.error, [prim]);
        
      });
  return Curry._1(logger, compile(loggable));
}

function prepend$1(res, str) {
  if (res.TAG === /* Ok */0) {
    return res;
  } else {
    return {
            TAG: /* Error */1,
            _0: prepend(res._0, str)
          };
  }
}

function append$1(res, str) {
  if (res.TAG === /* Ok */0) {
    return res;
  } else {
    return {
            TAG: /* Error */1,
            _0: append(res._0, str)
          };
  }
}

var Result = {
  prepend: prepend$1,
  append: append$1
};

exports.cause = cause;
exports.fromText = fromText;
exports.fromUnknown = fromUnknown;
exports.fromNative = fromNative;
exports.fromNativeVerbose = fromNativeVerbose;
exports.fromJsExn = fromJsExn;
exports.fromJsExnVerbose = fromJsExnVerbose;
exports.fromExn = fromExn;
exports.fromExnVerbose = fromExnVerbose;
exports.prepend = prepend;
exports.append = append;
exports.toString = toString;
exports.compile = compile;
exports.log = log;
exports.Result = Result;
/* No side effect */
