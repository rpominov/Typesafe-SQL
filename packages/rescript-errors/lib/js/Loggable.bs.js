// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Native$Errors = require("./Native.bs.js");
var Caml_splice_call = require("rescript/lib/js/caml_splice_call.js");

function cause(param) {
  return param.cause;
}

function fromText(message) {
  return {
          cause: /* None */0,
          message: [{
              TAG: /* Text */0,
              _0: message
            }]
        };
}

function fromExn(exn) {
  var err = Native$Errors.fromExn(exn);
  if (err === undefined) {
    return {
            cause: {
              TAG: /* Exn */0,
              _0: exn
            },
            message: [{
                TAG: /* Obj */3,
                _0: exn
              }]
          };
  }
  var err$1 = Caml_option.valFromOption(err);
  return {
          cause: {
            TAG: /* Native */1,
            _0: err$1
          },
          message: [{
              TAG: /* MessageOf */1,
              _0: err$1
            }]
        };
}

function fromExnVerbose(exn) {
  var err = Native$Errors.fromExn(exn);
  if (err === undefined) {
    return {
            cause: {
              TAG: /* Exn */0,
              _0: exn
            },
            message: [{
                TAG: /* Obj */3,
                _0: exn
              }]
          };
  }
  var err$1 = Caml_option.valFromOption(err);
  return {
          cause: {
            TAG: /* Native */1,
            _0: err$1
          },
          message: [{
              TAG: /* StackOf */2,
              _0: err$1
            }]
        };
}

function annotate(param, annotation) {
  return {
          cause: param.cause,
          message: [{
                TAG: /* Text */0,
                _0: annotation
              }].concat(param.message)
        };
}

function toString(param) {
  return param.message.map(function (node) {
                switch (node.TAG | 0) {
                  case /* Text */0 :
                      return node._0;
                  case /* MessageOf */1 :
                      var err = node._0;
                      var x = err.message;
                      if (x === "") {
                        return err.stack;
                      } else {
                        return x;
                      }
                  case /* StackOf */2 :
                      return node._0.stack;
                  case /* Obj */3 :
                      var val = node._0;
                      var str;
                      try {
                        str = JSON.stringify(val);
                      }
                      catch (exn){
                        return String(val);
                      }
                      if (str !== undefined) {
                        return str;
                      } else {
                        return String(val);
                      }
                  
                }
              }).join(" ");
}

function compile(param) {
  return param.message.map(function (node) {
              if (node.TAG !== /* MessageOf */1) {
                return node._0;
              }
              var err = node._0;
              var x = err.message;
              if (x === "") {
                return err;
              } else {
                return x;
              }
            });
}

function log(loggerOpt, loggable) {
  var logger = loggerOpt !== undefined ? loggerOpt : (function (prim) {
        console.error(prim);
        
      });
  var compiled = compile(loggable);
  for(var i = 0 ,i_finish = compiled.length; i < i_finish; ++i){
    Curry._1(logger, Caml_array.get(compiled, i));
  }
  
}

function logWhole(loggerOpt, loggable) {
  var logger = loggerOpt !== undefined ? loggerOpt : (function (prim) {
        Caml_splice_call.spliceApply(console.error, [prim]);
        
      });
  return Curry._1(logger, compile(loggable));
}

exports.cause = cause;
exports.fromText = fromText;
exports.fromExn = fromExn;
exports.fromExnVerbose = fromExnVerbose;
exports.annotate = annotate;
exports.toString = toString;
exports.compile = compile;
exports.log = log;
exports.logWhole = logWhole;
/* No side effect */
