// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Util = require("util");
var Curry = require("rescript/lib/js/curry.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Native$TypesafeSqlErrors = require("./Native.bs.js");

function cause(param) {
  return param.cause;
}

function fromText(message) {
  return {
          cause: /* None */0,
          message: [{
              TAG: /* MessageLiteral */0,
              _0: message
            }]
        };
}

function fromUnknown(obj) {
  return {
          cause: /* None */0,
          message: [{
              TAG: /* Unknown */4,
              _0: obj
            }]
        };
}

function fromNative(err) {
  return {
          cause: {
            TAG: /* Native */1,
            _0: err
          },
          message: [{
              TAG: /* MessageOf */1,
              _0: err
            }]
        };
}

function fromNativeVerbose(err) {
  return {
          cause: {
            TAG: /* Native */1,
            _0: err
          },
          message: [{
              TAG: /* StackOf */2,
              _0: err
            }]
        };
}

function fromJsExn(jsExn) {
  var err = Native$TypesafeSqlErrors.fromJsExn(jsExn);
  if (err !== undefined) {
    return fromNative(Caml_option.valFromOption(err));
  } else {
    return {
            cause: {
              TAG: /* Unknown */2,
              _0: jsExn
            },
            message: [{
                TAG: /* Unknown */4,
                _0: jsExn
              }]
          };
  }
}

function fromJsExnVerbose(jsExn) {
  var err = Native$TypesafeSqlErrors.fromJsExn(jsExn);
  if (err !== undefined) {
    return fromNativeVerbose(Caml_option.valFromOption(err));
  } else {
    return {
            cause: {
              TAG: /* Unknown */2,
              _0: jsExn
            },
            message: [{
                TAG: /* Unknown */4,
                _0: jsExn
              }]
          };
  }
}

function fromExn(exn) {
  if (exn.RE_EXN_ID === Js_exn.$$Error) {
    return fromJsExn(exn._1);
  } else {
    return {
            cause: {
              TAG: /* Exn */0,
              _0: exn
            },
            message: [{
                TAG: /* UnknownExn */3,
                _0: exn
              }]
          };
  }
}

function fromExnVerbose(exn) {
  if (exn.RE_EXN_ID === Js_exn.$$Error) {
    return fromJsExnVerbose(exn._1);
  } else {
    return {
            cause: {
              TAG: /* Exn */0,
              _0: exn
            },
            message: [{
                TAG: /* UnknownExn */3,
                _0: exn
              }]
          };
  }
}

function prepend(param, text) {
  return {
          cause: param.cause,
          message: [{
                TAG: /* MessageLiteral */0,
                _0: text
              }].concat(param.message)
        };
}

function append(param, text) {
  return {
          cause: param.cause,
          message: param.message.concat([{
                  TAG: /* MessageLiteral */0,
                  _0: text
                }])
        };
}

function prependUnknown(param, obj) {
  return {
          cause: param.cause,
          message: [{
                TAG: /* Unknown */4,
                _0: obj
              }].concat(param.message)
        };
}

function appendUnknown(param, obj) {
  return {
          cause: param.cause,
          message: param.message.concat([{
                  TAG: /* Unknown */4,
                  _0: obj
                }])
        };
}

function compile(param) {
  return param.message.map(function (node) {
              switch (node.TAG | 0) {
                case /* MessageLiteral */0 :
                    return {
                            TAG: /* Message */0,
                            _0: node._0
                          };
                case /* MessageOf */1 :
                    var err = node._0;
                    var x = err.message;
                    if (x === "") {
                      return {
                              TAG: /* Object */1,
                              _0: err
                            };
                    } else {
                      return {
                              TAG: /* Message */0,
                              _0: x
                            };
                    }
                default:
                  return {
                          TAG: /* Object */1,
                          _0: node._0
                        };
              }
            });
}

function toStrings(nodeToStringOpt, separatorOpt, error) {
  var nodeToString = nodeToStringOpt !== undefined ? nodeToStringOpt : (function (node) {
        if (node.TAG === /* Message */0) {
          return node._0;
        } else {
          return Util.inspect(node._0);
        }
      });
  var separator = separatorOpt !== undefined ? separatorOpt : " ";
  var arr = compile(error).map(Curry.__1(nodeToString));
  var result = [];
  for(var i = 0 ,i_finish = arr.length; i < i_finish; ++i){
    var item = arr[i];
    result.push(item);
    if (i < (arr.length - 1 | 0) && !item.endsWith(" ") && !item.endsWith("\n")) {
      result.push(separator);
    }
    
  }
  return result;
}

function toString(error) {
  return toStrings(undefined, undefined, error).join("");
}

function prepend$1(res, str) {
  if (res.TAG === /* Ok */0) {
    return res;
  } else {
    return {
            TAG: /* Error */1,
            _0: prepend(res._0, str)
          };
  }
}

function append$1(res, str) {
  if (res.TAG === /* Ok */0) {
    return res;
  } else {
    return {
            TAG: /* Error */1,
            _0: append(res._0, str)
          };
  }
}

var Result = {
  prepend: prepend$1,
  append: append$1
};

exports.cause = cause;
exports.fromText = fromText;
exports.fromUnknown = fromUnknown;
exports.fromNative = fromNative;
exports.fromNativeVerbose = fromNativeVerbose;
exports.fromJsExn = fromJsExn;
exports.fromJsExnVerbose = fromJsExnVerbose;
exports.fromExn = fromExn;
exports.fromExnVerbose = fromExnVerbose;
exports.prepend = prepend;
exports.append = append;
exports.prependUnknown = prependUnknown;
exports.appendUnknown = appendUnknown;
exports.compile = compile;
exports.toStrings = toStrings;
exports.toString = toString;
exports.Result = Result;
/* util Not a pure module */
